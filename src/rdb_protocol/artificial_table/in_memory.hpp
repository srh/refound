// Copyright 2010-2014 RethinkDB, all rights reserved.
#ifndef RDB_PROTOCOL_ARTIFICIAL_TABLE_IN_MEMORY_HPP_
#define RDB_PROTOCOL_ARTIFICIAL_TABLE_IN_MEMORY_HPP_

#include <map>
#include <string>
#include <vector>

#include "rdb_protocol/artificial_table/backend.hpp"
#include "rdb_protocol/datum.hpp"

/* This is the backend for an artificial table that acts as much as possible like a real
table. It accepts all reads and writes, storing the results in a `std::map`. It's used
for testing `artificial_table_t`.  Each server holds a separate map. */

class in_memory_artificial_table_fdb_backend_t :
    public artificial_table_fdb_backend_t, home_thread_mixin_t
{
public:
    explicit in_memory_artificial_table_fdb_backend_t(name_string_t const &table_name)
        : artificial_table_fdb_backend_t(table_name)
    {
    }

    ~in_memory_artificial_table_fdb_backend_t() {
    }

    bool read_all_rows_as_vector(
            UNUSED FDBDatabase *fdb,
            auth::user_context_t const &user_context,
            const signal_t *interruptor,
            std::vector<ql::datum_t> *rows_out,
            UNUSED admin_err_t *error_out) override;

    bool read_row(
            UNUSED FDBTransaction *txn,
            auth::user_context_t const &user_context,
            ql::datum_t primary_key,
            const signal_t *interruptor,
            ql::datum_t *row_out,
            UNUSED admin_err_t *error_out) override;

    bool write_row(
            UNUSED FDBTransaction *txn,
            auth::user_context_t const &user_context,
            ql::datum_t primary_key,
            UNUSED bool pkey_was_autogenerated,
            ql::datum_t *new_value_inout,
            const signal_t *interruptor,
            UNUSED admin_err_t *error_out) override;

private:
    std::map<std::string, ql::datum_t> data;
};

#endif /* RDB_PROTOCOL_ARTIFICIAL_TABLE_IN_MEMORY_HPP_ */

